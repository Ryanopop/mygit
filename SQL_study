모델은 현실에서 일어날수있는 다양한 현상에 대하여 일정한 표기법에 의해 표현해둔 모형이라 할수있고 
이모델을 만들어가는 일을 모델링이라 한다.
이 모델링은 
현실세계를 반영해야하고 
단순화하여 표현해야한다.
관리하고자 하는 데이터를 모델로 설계한다.

모델링의 특징
추상화(Abstaction) : 아이디어나 개념을 간략히 표현하는 과정
단순화(simplifcation) : 현실세계를 정해진 표기법으로 단순하고 쉽게 표현한다는 말
명확화(clarity) : 불명확힌 요소를 제거하고 명확히 해석할수있게 기술한다는 말

모델링의 관점
데이터 관점(what, data)
데이터 위주의 모델링 (어떤 데이터들이 업무와 얽혀있는지 데이터간에 어떤 관계가 있는지)

프로세스 관점(how data)
프로세스 위주의 모델링 (실제로 처리하고있는 일은 무엇인지 앞으로 처리해야하는일은 무엇인지)

데이터와 프로세스의 상관 관점(data vs process,interaction)
데이터와 프로세스 관계를 위주로 모델링(프로세스의 흐름에 따라 데이터가 어떤 영향을 받는지)

모델링의 세가지 단계

개념적 데이터 모델링 (conceptual data modeling)
전사적데이터 모델링 수행시 행해짐 추상화 레벨이 가장 높음 이단계에는 업무중심적이고 포괄적인 모델링 이 진행

논리적 데이터 모델링(logical data modeling)
재사용성이 가장높은 모델링 데이터베이스 모델에 대한 key,속성, 관계등 표현하는 단계

물리적 데이터 모델링(physical data modeling)
실제 데이터베이스 구현할수록 성능이나 가용성등의 물리적인 성격을 고려하여 모델을 고려하여 표현하는 단계


스키마 

3단계 스키마 구조

외부 스키마(txternal schema)
 사용자 관점 : 사용자가 보는 데이터베이스의 스키마를 정의

개념스키마 (conceptual schema)
통합적 관점 : 모든 사용자가보는 db의 스키마를 통합하여 전체 db를 나타내는것 데이터들간의 관계를 나타낸다

내부스키마(inernal schema)
물리적 관점 : 물리적인 저장구조를 나타냄 실질적인 데이터 저장구조나 컬럼정의 인덱스등이 포함된다.

3단계 스키마구조가 보장하는 독립성 
DB가 실제로 표현되는 물리적인 방식을 분리하여 독립성을 보장하기 위한것

논리적 독립성 : 개념시키마가 변경되어도 외부스키마는는 영향을 받지않는다.
물리적 독립성 : 내부스키마가 변경되어도 외부/개념스키마는 영향을 받지않는다.

ERD : 시스템에 어떤 엔터티들이 존재하며 그들간의 어떤 관계를 나타내는 다이어그램

엔터티(Entity) = 독립체
업무에서 쓰이는 데이터를 용도별로 분류한 그룹


엔터티의 특징
1.업무에서 쓰이는 정보여야함
2.유니크함을 보장할수있는 식별자가있어야함 
3.2개이상의 인스턴스르 가지고 있어야함
4.반드시 속성을 가지고 있어야함
5.다른 엔터티와 1개이상의 관계를 가지고 있어야함

엔터티의 분류
유형 vs. 무형

유형 엔터티 : 물리적인 형태 존재,안정적,지속성
개념 엔터티 : 물리적인 형태없음 개념적
사건 앤터티 : 행위르 함으로써 발생,비번함,통계자료로 이용가능

발생시점

기본엔터티 : 독립적으로 생성됨, 자식 엔터티를 가질수있음
중심엔터티 : 기본앤터티에서 파생된다, 행위 앤터티 생성
행위엔터티 : 2개이상의 엔터티로부터 파생

속성(Attribute)
속성은 더이상 쪼개지지 않는 레벨이여야하고 프로세스에 필요한 항목이여야함 (업무상 필요치않는 속성은 삭제함이 바름직함)

속성값
각각의 속성은 속성값을 가짐 속성값은 엔터티에 속한 하나의 인스턴스를 구체적으로 나타네주는 데이터
하나의 속성은 하나의 속성값만 기질수 있다(하나의 속성이 여러개의 속성값을 갖는경우 별도의 엔터티로 분리하는것이 바람직함)

엔터티,인스턴스,속성,속성값의 관계
1.한개의 엔터티는 2개이상의 인스턴스를 갖는다.
2.한개의 인스턴스는 두개이상의 속성을 갖는다.
3.한개의 속성은 하나의 속성값을 가진다.
(엔터티는 2개이상의 인스턴스를 갖고 인스턴스는 2개이상의 속성을갖고 속성은 하나의 속성값을 갖는다)

분류
(특성에 따른 분류)
1.기본속성(Basic Attrbute)
업무프로세스 분석을 통해 바로 정의가 가능한 속성
필요한 내용을 바로 정의가능함 일부 설계속성과 파생속성을 제외한 모든속성이 기본속성에 해당
2. 설계 속성(Designed Attrbute)
업무상에 존재하지는 않지만 설계하다보니 필요하여 도출해는 속성
설계과정중 합리적모델링을 위해 만들어진속성
설계속성을 만들어서 고유번호를 할당함으로 인스턴스에 유니크함을 부여함
3.파생속성(Derived Attrbute)
다른속성의 속성값을 계산하거나 특정한 규직으로 변형하여 생성한 속성
다른속성에서 파생된 속성 계산된 값이나 가공된 값이 이에 속함 
파생속성을 설계할시 반드시 데이터의 정합성이 요구되어야함

PK(Primary key)속성 : 
엔터티의 인스턴스를 식별할수있는 속성
인스턴스에 유니크함을 부여하는속성(1개만 존재함)
FK(Foreign key)속성 :
다른 엔터티의 속성을 가져온 속성
다른 엔터티와 관계를 맺게해주는 매게체 역할을 하는 속성

일반속성 : PK,FK를 제외한 모든속성

관계(Relationship)
엔터티와 엔터티와의 관계를 의미 어떤 연관성이 있는지를 타입을 분류하여 존재관계와 행위 관계로 나눌수있음

존재관계 : 존재자체로 연관성이 있는관계를 말함

행위관계 : 특정한 행위를 함으로써 생기는 관계를 말함

관계 표기법
관계명(membership) : 
관계의 이름 앤터티와 엔터티가 어떤 관계를 맺고있는지를 말해주는 문장 엔터티의 관점에서 관계명을 하나씩 갖는다
명확한 문장으로 표현해야하고 현재형이여야 한다
관계차순(cardinality) : 
관계에서 참여하는수 
각엔터티에서 참여하는수를 의미 일반적으로 1:1 1:M, M:N의 형식으로 구분
관계선택사양(optionality) : 
필수인지 선택인지의 여부

식별자 
속성중 각각읜 인스턴스를 구분가능하게 만들어주는 대표적인 속성

주식별자(기본키, PK(Primary Key))
특징
유일성 : 각 인스턴스에 유니크함을 부여하여 식별가능하게 만듬
최소성 : 유일성을 보장하는 최소 개수의 속성이어야함
불변성 : 속성값이 변하면 안됨
존재성 : 속성값이 null일수 없다 (없는 값일수 없다)


분류 
1.대표성 여부
1)주식별자(primary key) : 유일성, 최소성, 불변성, 존재성을 가진 대표식별자, 다른엔터티와 참조관계로 연결
2)보조식별자(alternate identifer): 인스턴스를 식별할수있지만 대표식별자가 아님, 다른엔터티와 참조관계로 연결되어있지않음

2. 스스로 생성되었는지 여부
1)내부식별자(internal identifer) : 엔터티 내부에서 스스로 생성된 식별자
2)외부식별자(Foreign identifer) : 다른 엔터티에서 온 식별자, 다른엔터티와 연결고리 역할

3. 단일속성 여부
1)단일식별자(Single identifter): 하나의 속성으로 구성된 식별자
2)복합식별자(Composite identifer) : 두개이상으로 구성된 식별자

4.대체 여부
1)원조 식별자(original identifter): 업무프로세스에 존재하는 식별자, 가공되기전 원래의 식별자
2)대리 식별자(surrogate identifter) : 주식별자의 속성이 두개이상인경우 그속성들을 하나로 묶어서 사용하는 식별자(인조식별자)

식별자의 관계
자식엔터티의 데이터와 부모엔터티에 반드시 존재해야한다.
부모엔터티와 자식엔터티는 1:1 또는 1:M관계가 형성된다.

정규화
데이터 정합성을 위해 엔터티를 작은단위로 분리하는 과정
정규화를 할경우 처리조건에 따라 성능이 좋아지는 경우가있고 저하되는 경우가 있는데  보통 입력,출력,수정,삭제는 일반적으로 향상된다.
정규화를 하면 엔터티가 계속 증가함으로 join으로 인한 조회성능 저하가 발생할수있다.

1. 제1정규형
모든 속성은 반드시 하나의 값만 가져야한다.
 
2.제2정규형
엔터티의 모든 일반속성은 반드시 모든 주식별자에 종속되어야한다.
주식별자가 단일식별자가 아닌 복합식별자일경우 일반속성이 주식별자의 일부에만 종속될수있다.

3.제3정규형
주식별자가 아닌 모든 속성간에는 서로 종속될수없다.

정규화시 주의 사항
적절한 정규화는 성능상 이롭지만 지나친 정규화는 오히려 성능 저하를 일으킬수있다.

반정규화
데이터의 조회성능을 향상시키기위해 데이터의 중복을 허용하거나 데이터를 그룹핑 하는 과정
조회성능은 향상되지만 입력,수정,삭제성능은 저하될수있다.
보통 정규화 과정이 끝난후 거지게된다.

테이블의 반정규화
1)테이블병합
1. 1:1 관계 테이블 병합
2. 1:M 관계 테이블 병합
3. 슈퍼 서브 타입 테이블 병합

2)테이블 분할
1. 테이블 수직분활(속성 분활)
   엔터티의 일부속성을 별도의 엔터티로 분할 (1:1 관계 성립)
2.테이블 수평분활(인스턴스 분활, 파티셔닝)
  엔터티의 인스턴스르 특정기준으로 별도의 엔터티로 분할(파티셔닝)

3)테이블 추가
1.중복 테이블 추가
데이터의 중복을 감안하더라도 성능상 필요하다고 판단되는 경우 별도의 엔터티를 추가한다.
2.통계테이블  추가
3.이력 테이블 추가
4.부분 테이블 추가

컴럼 반정규화
1) 중복 컬럼 추가
업무 프로세스상 JOIN이 필요한 경우가 많아 추가하는것이 성능 측면에서 유리할경우`고려
2)파생 컬럼 추가
프로세스 수행시 부하가  염려되는 계산값을 미리 컬럼으로 추가하여 보관하는 방식
3)이력 테이블 컬럼 추가
대량의 이력테이블을 조회할떄 속도가 느려질것을 대비하여 조회 기준이 될 것으로 판단되는 컬럼을 미리 추가해두는 방식

테이블 병합
업무 프로세스상 join이 필요한 경우가 많아 테이블통합하는것이 성능에 유리할경우 고려
엔터티의 속성 개수가 많으면 병합했을경우 중복 데이터가 많아지므로 테이블 병합에 적합지 못함

트랜잭션(Transaction)
데이터를 조작하기위한 하나의 논리적인 작업 단위이다.

NULL
NULL = 존재하지않음 즉 값이 없음을 의미한다. 

--------------- -------------------sql활용 ----------------------------------------------------------
관계형 데이터베이스 = RDB(Relational Database)
관계형 테이터 모델에 기초를 둔 데이터베이스

RDBMS 종류 :
MARAIA DB
ORACLE  오라클 기반
MYSQL	오라클이 인수함
MSSQL	마이크로소프트 기반 db
POSTGRESQL 아마존기반 DB

table
관계형 테이터베이스느 모든 데이터를 2차원 테이블 형태로 표현함
테이블은 각각 세로열과 가로열로 테이블을 만든다.

테이블의 세로열을 컬럼 가로열을 로우라고 함
테이블은 관계형 테이터베이스의 기본단위이고 주된 목적은 데이터를 활용하는데 있다(테이블 형태로 조회,변경,삭제할수있다)

SQL(Structured Query Language)
관계형 데이터베이스에서 데이터를 다루기 위해 사용하는 언어
컴뷰터와 사람이 사용하는 언어가 다르기떄문에 컴퓨터가 이해할수있는 sql를 사용하여 명령어를 실행함

1) SELECT문
저장되어 있는 데이터를 조회하고자 할떄 사용
컴럼을 따로 표시하지않고 *(ASTERISK)를 사용하면 전체컬럼이 조회된다,
테이블명이나 컬럼명에 별도의 별칠을 붙여줄수있는데 별칭을붙이는 이유는 여러게의 테이블을 JOIN하거나 서브커리가 있을경우 
테이블명은 비교적 길기떄문에 짧게 줄여쓰기 위해 ALIAS(별칭)을 붙혀주는 것이다.

산술연산자 사용시  테이블에 null값이 포함되어있으면 결과값은 null로 표기된다.

합성연산자 
sql문을 짤떄 || 을 사용하여 문자와 문자를 연결할떄 사용한다.

문자함수
1)CHR(아스키코드)
아스키코드는 총128개의 문자르 숫자로 표현할수있도록 정의해둔 코드이다.
CHAR함수는 ASCII코드를 입력했을떄 매핑되는 함수가 뭔지 알려주는 함수이다.

2)LOWER(문자열)
문자열을 소문자로 변횐해주는 함수

3)UPPER(문자열)
문자열을 대문자로 변환해주는 함수

4)LTRIM(문자열[,특정문자]) *[]는 옵션
특정문자를 따로 명시치않으면 왼쪽 공백을 제거함
특정문자에 포함되어있으면 제거하고 포함되어있지않으면 멈춤

5)RTRIM(문자열[,특정문자])
특정문자를 따로 명시치않으면 오른쪽 공백제거
특정문자에 포함되어있으면 제거하고 포함되어있지 않으면 멈춤

6) TRIM([위치][특정문자][FORM]문자열)
옵션이 하나도 없을 경우 문자열의 왼쪽과 오른쪽 공백을 제거함
LTRIM, RTRIM과 다른점은 특정문자를 한글자씩 지정할수 있음

차이점
LTRIM = 왼쪽문자열 공백제거
RTRIM = 오른쪽문자열 공백제거
TRIM = 양쪽 문자열 공백 제거
LTRIM,RTRIM은 특정문자 전체를 제거하고 TRIM은 특정문자의 전체를 제거할수있다.

7)SUBSTR(문자열,시작점[.길의])
문자열의 원하는부분만 잘라서 변환해주는 함수 길이를 명시하지 않으면 시작점부터 문자열의 끝까지 반환
SQL문의 숫자는 각각 앞은 출력위치, 문자의 길이를 표현한다.

8)LENGTH(문자열)
문자열의 길이를 반환해주는 함수

9)REPLACE(문자열, 변경전 문자열[,변경후 문자열])
 문자열에서 변경전 문자열을 찾아 변경전 문자열로 바꿔주는 함수

숫자함수
1)ABS(수)
수의 절대값을 반환해주는 함수
절대값을 출력하기떄문에 음수도 양수값으로 변환하여 출력함
EX)SELECT ABS(-1) FROM DUAL; -> 1

2)SIGN(수)
수의 부호를 반환해주는 함수 양수면 1, 음수면 -1, 0이면 0을 반환한다.
여기서 NULL을 입력해주면 NULL값을 반환한다.

3)ROUND(수[,자릿수])
수를 지정된 소수점 자릿수까지 반올림하여 반환해주는 함수
자릿수를 지정해주지않으면 디폴트는 0이고 반올림된 정수로 반환 
자릿수가 음수일경우 지정된 정수부를 반올림하여 반환한다.

4)TRUNC(수[,자릿수])
수를 지정된 소수점 자릿수까지 버림하여 반환해주는 함수
디폴트는 0이고 반올림된 정수로 반환
자릿수가 음수일경우 지정된 정수에서 버림하여 반환 한다.

5)CEIL(수)
소수점이하의 수를 반올림한 정수로 반환해주는 함수

6)FLOOR(수)
소수점이하의 수를 버림하여 정수로 반환출력해주는 함수

7)MOB(수1,수2)
수1과 수2를 나눈 나머지를 반환해주는 함수

날짜함수

1)SYSDATE
현재의 연,월,일,시,분,초를 반환해주는 함수 시스템의 설정마다 출력문이 달라질수도있음

2)EXTRACT(특정단위 FROM 날짜 데이터)
날짜 데이터에서 특정단위 만을 출력해서 반환해주는 함수

3)ADD_MONTHS(날짜데이터, 특정 개월수)
날짜 데이터에서 특정 개월수를 더한 날짜를 반환해주는 함수이다.
날짜의 다음달이나 이전달에 일자가 존재하지않으면 해달월의 마지막 일자가 출력된다.

----변환함수 
데이터베이스에서 데이터 유형에 대한 형변환을 할수있는 방법은 두가지가 있다. 
명시적 형변환 : 변환함수를 사용하여 데이터 유현변환을 명시적으로 나타냄
암시적 형변환 : 데이터베이스가 내부적으로 알아서 데이터 유형을 변환함

암시적형변환이 가능하다고 해서 컬럼의 데이터 유형을 고려하지않고 sql을 작성하면 성능저하를 불러올수있으니 
되도록 명시적 형변환을 사용하는것을 권4장함

-----명시적 형변환에 사용하는 함수------
TO_NUMBER(문자열)
문자열을 숫자형으로 변환해주는 함수

TO_CHAR(수OR날짜[,포맷])
수나 날짜형 데이터를 포맷 형식으로 변환해주는 함수

TO_DATE(문자열,포맷)
포맷 형식의 문자형 데이터를 날짜형으로 변환해주는 함수

null 함수
1) NVL(인수1,인수2)
인수1값이 NULL일경우 인수2를 반환하고 NULL이 아닐경우 인수1을 반환해주는 함수

2)NULLIF(인수1,인수2)
인수1과인수2의 값이 같으면 NULL값을 반환하고 같지않다면 인수1을 반환해주는 함수.

3)coalesce(인수1,인수2,인수3...)
null이 아닌 최초의 인수를 반환해주는 함수

사용할떄 주의할점 ------
인수가 NUMBER 형태가닌 CHAR형태가 들어가있으면 인수값이 잘못되었다는 에러가 발생함

CASE
함수와 성격은 같으나 표현방식이 함수보다는 구문에 가깝다 
문장으로는 ~이면, ~이고, ~이면, ~이다 식으로 표현됨
oracle에서는 DECODE함수를 사용한다.

------------WHERE절------------------
INSERT를 제외한 M=DML문을 수행시 원하는 데이터만 골라 수행할수있도록 해주는 구문.
찾는 컬럼이 아닌 컬럼만 SELECT할수도있는데 UPDATE나 DELETE도 마찬가지다.

문자형 컬럼을 비교조건으로 사용하려면 우측 상수값을 반드시 인용부호로 감싸줘야한다.

SQL의 논리연산자는 순서와 상관없이()-> NOT->AND->OR순으로 처리된다.

SQL의 비교연산자
1)BETWEEN A AND B
의미 A와B사이 EX)WHERE COL BETWEEN 1 AND 10

2)LIKE'비교문자열'
비교 문자열을 포함 EX)WHERE COL LIKE '방탄%'

3)IN(LIST)
LIST 중 하나와 일치 EX) WHERE COL IN(1,3,5)

4)IS NULL
NULL값 EX)WHERE COL IS NULL

SQL 부정 연산자
1)NOT BETWEEN A AND B
A와 B 사이가 아님(A,B 미포함) EX) WHERE COL NOT BETWEEN 1 AND 10

2)NOT IN(LIST)
LIST 중 일치하는 것이 없음 EX)WHERE COL NOT IN(1,3,5)

3)IS NOT NULL
NULL 값이 아님 EX)WHERE COL IS NOT NULL

논리 연산자
1)AND
모든조건이 TRUE여야함 EX)WHERE COL>1 AND COL<10
2)OR
하나 이상의 조건이 TRUE여야함 EX)WHERE COL =1 OR COL1 =10
3)NOT
TRUE면 FLASE고 FLASE면 TRUE를 출력 Ex) WHERE NOT COL>10

논리 연산자에는 처리순서가 존재하는데 SQL에 명시된 조건과는 관게없이 ()->NOT-> AND->OR순으로 처리된다.
---------------GORUP BY,HAVING절파트 --------------------
GORUP BY
GORUP BY 는 말그대로 데이터를 그룹별로 묶을수 있도록 해주는 절이다
GOUUP BY 뒤에는 그룹핑의 기준이 되는 컬럼이 오게된다.
여기서 뒤에오는 컬럼은 하나가 될수도있고 그이상이 될수도있다.

집계함수
데이터를 그룹별로 나누면 그룹별로 집계 데이터를 도출하는 것이 가능해진다.
집계함수의 종류
1)COUNT(*)
전체 ROW를 COUNT하여 반환
2)COUNT(컬럼)
컬럼값이 NULL인 ROW를 제외하고 COUNT하여 반환
3)COUNT(DISTINCT 컬럼)
컬럼값이 NULL이 아닌 ROW에서 중복을 제거하고 COUNT하여 반환한다.
4)SUM(컬럼)
컬럼의 합계를 반환
5)AVG(컬럼)
컬럼값들의 평균을 반환
6)MIN(컬럼)
컬럼값들의 최소값을 반환
7)MAX(컬럼)
컬럼값들의 최대값을 반환

HAVING
HAVING절은 GROUP BY 절을 사용할떄 WHERE 절처럼 사용하는 조건절이라 생각하면됨
주로 데이터를 구룹핑한후 특정 그룹을 골라낼떄 사용

HAVING 절은 논리적으로 GROUP BY 절뒤에 수행되기 떄문에 그룹핑후에 가능한 집계함수로 조건을 부여할수있다.
그리고 HAVING 절은 논리적으로 SELECT 절전에 수행되기 떄문에 
SELECT 절에 명시되지 않는 집계함수로도 조건부여가 가능함

주의점
WHERE 절을 사용해도되는 조건까지 HAVING 절을 써버리면 성능상 불리할수도있다.
이유 : WHERE 절에서 필터링이 선행되어야 GROUP BY 할 데이터량이 줄어들기 떄문이다.

SELECT 문의 논리적 수행순서
FROM-> WHERE-> GROUP BY -> HAVING -> SELECT -> ORDER BY

ORDER BY
ORDER BY 절은 SELECT 문에서 논리적을 맨마지막에 수행
ORDER BY절을 사용하면 SELECT한 데이터를 정렬할수있다
ORDER BY절을 사용하지 않으면 데이터는 임의의 순서대로 출력된다.

ORDER BY의 종류
ASC(Ascending) : 오름차순
DESC(Descending) : 내림차순
옵션을 생략할시 ASC가 기본값이 된다.

--------join--------

JOIN
조인이란 단어는 각기다른 두개의 집단이 합해질떼 주로 사용하는 단어다
데이터베이스에서도 join은 각기 다른 두개의 테이블을 한번에 보여줄떄 사용하는 쿼리이다.
실무에서 사용하는 sql을 작성할떄 8할이상이 join쿼리 라고할정도로 많이 쓰이는 쿼리이다.
JOIN할시 2개의 테이블의 값만 출력할수있는 것이아닌 여러테이블의 값을 합쳐서 출력할수있다.


1)equi join
EQUI JOIN은 EQULA(=) 조건으로 JOIN하는 것 
두개의 테이블의 컬럼의  조건이되는 값이 같은것만 출력할떄 사용할수있다
여기서 따로 출력하고 싶은 것이 있다면 where 조건을 추가해주면된다.
EX)SELECT A.PROFESSOR,
	  A.PROFESSOR_ID,
	  B.COURSE_ID,
	  B.COURSE_NAME
FROM A.PRODUCT_NAME, B.PRODUCT
WHERE A.PRODUCT_CODE = B.PRODUCT_CODE;


2)Non EQUI JOIN
Equak(=) 조건이 아닌 다른 조건(BETWEEN, >,>=,<,<=) EQUAL이 아닌 비교연산자로 JOIN하는 방식이다.
EX)SELECT A.PROFESSOR,
	  A.PROFESSOR_ID,
	  B.COURSE_ID,
	  B.COURSE_NAME
FROM A.PRODUCT_NAME, B.PRODUCT
WHERE A.PRODUCT_CODE BETWEEN B.PRODUCT_CODE AND B.END_DATE;

&OUTER JOIN
OUTER JOIN은 앞써 본 JOIN 조건에 만족하지 않는 행들도 출력되는 형태이다.
종류
1)LEFT OUTER JOIN
JOIN한 테이블의 곂치는 부분과 LEFT TABLE의 값을 출력해준다
SQL에서 왼쪽에 표기된 테이블의 데이터는 무조건 출력되는 JOIN이다.
오른쪽 테이블에 JOIN되는 데이터가 있든 없든 출력되는 형식이라 이해하면 쉬움
JOIN되는 데이터가 없는 ROW들은 오른쪽테이블 컬럼의 값이 NULL로 변한다.

2)RIGHT OUTER JOIN
JOIN한 테이블의 곂치는 부분과 RIGHT TABLE의 값을 출력해준다.
SQL에서 오른쪽에 표기된 테이블의 데이터는 무조건 출력되는 방식이다.
LEFT조인과 반대로 데이터가 없는 ROW들은 왼쪽테이블 컬럼의 값이 NULL로 변한다.

3)FULL OUT JOIN
왼쪽, 오른쪽 테이블의 모든 데이터가 출력되는 형식이다. LEFT JOIN과 RIGHT JOIN의 합집합이라고 이해하면 쉬움(단 중복값은 제거된다)

4)NATURAL JOIN
A테이블과 B테이블에서 같은 이름을 가진 컬럼들이 모두 동인한데이터를 가지고 있을경우 JOIN되는 형식
A와B테이블의 값이 동일하지않는 데이터는 컬럼이 동일하지 않기떄문에 JOIN해도 출력이 되지않는다.
이경우 ORACLE에서는 USING조건절을 사용하여 같은이름을 가진 컬럼만 JOIN에 이용할수있다.

5)CROSS JOIN
 A테이블과 B테이블 사이에 JOIN조건이 없는경우 조합할수있는 모든 경우를 출력하는 방식이다.
다른말로는 CARTESIAN PRODUCT라고 한다.

*ORACLE에서는 모든 행의 출력되는 테이블의 반대편 테이블에(+) 기호를 붙혀서 작성하면된다.

& STANDARD JOIN
1)INNER JOIN
JOIN 조건에 충족되는 데이더만 출력
앞에서본 OUTER JOIN과 다른점은 JOIN 조건을 ON절을 사용해서 작성해야한다.
EX) SELECT A.PROFESSOR,
	  A.PROFESSOR_ID,
	  B.COURSE_ID,
	  B.COURSE_NAME
FROM PRODUCT_NAME A INNER JOIN PRODUCT B
ON A.PRODUCT_CODE = B.PRODUCT_CODE

-----서브쿼리-----------

서브쿼리(subquery)
하나의 쿼리 안에 존재하는 또하나의 쿼리를 말하는것

서브쿼리는 위치에 따라 나눌수있다

SELECT절 = 스칼라 서브쿼리(Scalar SubQuery)
FROM절   = 인라인 뷰(InLine view)
WHERE,HAVING절 = 중첩 서브쿼리=(Nested subQuery)

스칼라 서브쿼리(scalar subquery)
주로 select 절에 위치하지만 컬럼이 있는 대부분의 위치에 올수있다
컬럼대신 사용함으로 반드시 하나의 값만 반환해야하면 그렇지않으면 에러가 발생한다.

인라인 뷰(inline view)
from절등 테이블명이 올수있는 위치에 사용가능하다.

중첩 서브쿼리(nested subquery)
WHERE절과 HVAING절에 사용할수있다. 중첩서브쿼리는 메인쿼리의 관계에따라 비연관 서브쿼리랑 연관 서브쿼리로 나눌수있다

비연관 서브쿼리(Uncorrelated subquery)
메인쿼리와 관계를 맺고있지 않음
서브쿼리내에 메인쿼리의 컬럼이 존재하지 않음

연관 서브쿼리(Correlated subquery)
메인쿼리와 관계를 맺고있음
서브쿼리 내에 메인쿼리의 컬럼이 존재

중첩서브쿼리의 데이터 형태
1)단일행 (single Row) 서브쿼리
서브쿼리가 1건 이하의  데이터를 반환
단일 행 비교연산자와 함꺠사용함 ex)(=,<,>,=>,<=)
항상 1건 이하의 결과만 반환

2)다중행(mutil Row) 서브쿼리
서브쿼리가 여러건의 데이터를 반환
다중행 비교 연산자와 함꺠 사용함 ex) (IN, ALL, ANY,SOME,EXISTS)
2건 이상의 결과만 반환함

3)다중 컬럼(Mutil Column) 서브쿼리
서브쿼리가 여러 컬럼의 데이터를 반환
다중컬럼의 출력값과 같은것은 출력할수있다.

-------뷰(View)-------------
뷰(view)
특정 SELECT문에 이름을 붙혀서 재사용성을 높히기위해 저장해둔 오브젝트
SQL에서 테이블 처럼 사용할수있다
뷰 = 가상테이블 (실제 데이터를 저장하지는 않고 해당 데이터를 조회해오는 SELECT문만 가지고 있다.

------집합 연산자-----
집합 연산자는 각 쿼리의 결과 집합을 가지고 연산을 하는 명령어다
JOIN된 테이블의 출력문
집합연산자의 종류
1)UNION ALL
  각 쿼리의 결과 집합의 합집합이다, 중복되는 행도 그래도 출력된다
2)UNION 
  각쿼리의 결과 집합의 합집합이다, 중복되는 행은 한줄로 출력된다.
3)INTERRSECT
 각 쿼리의 결과집합의 교집합이다, 중복되는 행은 한줄로 출력된다.
4)MINUS/EXCEPT
   앞에있는 쿼리의 결과집합에서 뒤에있는 쿼리의 결과집합을 뺸 차집합이다,
   중복되는 행은 한줄로 출력된다.

각쿼리의 결과 집합의 합집합에 중복된 행이없을때는 UNION ALL과 UNION 모두 같은 결과가 도출되지만
UNION을 사용할떄 데이터베이스의 내부적으로 중복된 행을 제거하는 과정을 거쳐야하므로 성능상 불리할수도 있다.

------------그룹함수------------
데이터를 GROUP BY 하여 나타낼수있는 데이터를 구하는 함수이다
역할에 따라 구분하면 집계함수와 소계(총계)함수로 구분할수있다

집계함수 = COUNT, SUM, AVG, MAX, MIN 등
소계(총계)함수 = ROLLUP, CUBE, GROUPING SET 등

ROLLUP
소그룹 간의 총계를 계산하는 함수이다

1)ROLLUP(A)
A로 그룹핑
총합계

2)ROLLUP(A,B)
A,B로 그룹핑
A로 그룹핑
총합계

3)ROLLUP(A,B,C)
A,B,C로 그룹핑
A,B로 그룹핑
A로 그룹핑
총합계

CUBE
소스간의 소계및 총계를 다차원적으로 계산할수있는 함수
GROUP BY가 일반향으로 그룹핑하면서 소계를 구했다면
CUBE은 조합할수있는 모든그룹에 대한 소계를 구한다.

EX)
1)CUBE(A)
A로 그룹핑
총합계

2)CUBE(A,B)
A,B로 그룹핑
A로 그룹핑
B로 그룹핑
총합계

3)CUBE(A,B,C)
A,B,C로그룹핑
A,B로 그룹핑
A,C로그룹핑
B,C로그룹핑
A로그룹핑
B로그룹핑
C로그룹핑
총합계

GROUPING SETS
특정 항목에 대한 소계를 계산하는 함수이다 인자값으로 ROLLUP이나 CUBE를 사용할수있다
총계를 더해주고 싶은경우 인자값에 ()나 ROLLUP를 적용해주면된다.
ROLLUP 함수는 인수의 순서에따라 결과가달라지며
CUBE함수와 GROUPING SETS함수는 인수의 순서가 바뀌어도 같은 결과를 출력한다.
EX)
GROUPING SETS(A,B)
A로그룹핑
B로그룹핑
GROUPING SETS(A,B())
A로그룹핑
B로그룹핑
총합계
GROUPING SETS(A, ROLLUP(B))
A로그룹핑
B로그룹핑
총합계
GROUPING SETS(A,ROLLUP(B,C))
A로그룹핑
B,C로 그룹핑
B로 그룹핑
총합계
GROUPING SETS(A,B,ROLLUP(C))
A로 그룹핑
B로그룹핑
C로 그룹핑
총합계

GROUPING
ROLLUP,CUBE,GROUPING SETS등과 함깨쓰이며 소계를 나타내는 ROW를 구분할수있게해준다.
소계를 나타내는 ROW에서 그룹핑의 기준이되는 컬럼을 제외하고는 모두 NULL값으로 출력되었지만
GROUPING을 사용하면 원하는 위치에 원하는 텍스트를 출력할수있다.
ORACLE의 경우 DECODE문으로 CASE문을 대체할수있다.

